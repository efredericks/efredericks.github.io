---
layout: post
title: Computing Club Tutorial - Entity Component System (ECS)
description: tutorial on ECS in p5js
# image: assets/img/z-is-for-zero.png
# responsiveImage:
#   - src: assets/img/300.png
#     size: 300
#   - src: assets/img/600.png
#     size: 600
#   - src: assets/img/z-is-for-zero.png
#     size: 900
type: blog
# play:
#     - name: YouTube
#       url: https://www.youtube.com/
#     - name: SoundCloud
#       url: https://soundcloud.com/
# buy:
#   - url: https://backfromvoid.bandcamp.com/track/if-i-want-you-to
#     name: BandCamp
# embed_player:
#   type: bandcamp
#   src: track=2250182265/size=large/bgcol=ffffff/linkcol=0687f5/tracklist=false/artwork=small/transparent=true/
carousels:
  - images: # random
    - image: /assets/img/GenerativeGI/random/img-6.png
    - image: /assets/img/GenerativeGI/random/img-22.png
    - image: /assets/img/GenerativeGI/random/img-46.png
    - image: /assets/img/GenerativeGI/random/img-62.png
    - image: /assets/img/GenerativeGI/random/img-64.png
    - image: /assets/img/GenerativeGI/random/img-67.png
    - image: /assets/img/GenerativeGI/random/img-71.png
    - image: /assets/img/GenerativeGI/random/img-94.png
    - image: /assets/img/GenerativeGI/random/img-94-1.png
    - image: /assets/img/GenerativeGI/random/img-98.png
  - images: # single no clear
    - image: /assets/img/GenerativeGI/no-clear-single/img-10047.png
    - image: /assets/img/GenerativeGI/no-clear-single/img-10050.png
    - image: /assets/img/GenerativeGI/no-clear-single/img-10051.png
    - image: /assets/img/GenerativeGI/no-clear-single/img-10057.png
    - image: /assets/img/GenerativeGI/no-clear-single/img-10063.png
    - image: /assets/img/GenerativeGI/no-clear-single/img-10066.png
    - image: /assets/img/GenerativeGI/no-clear-single/img-10080.png
    - image: /assets/img/GenerativeGI/no-clear-single/img-10095.png
    - image: /assets/img/GenerativeGI/no-clear-single/img-10097.png
    - image: /assets/img/GenerativeGI/no-clear-single/img-10099.png
  - images: # single clear
    - image: /assets/img/GenerativeGI/clear-single/img-10045.png
    - image: /assets/img/GenerativeGI/clear-single/img-10048.png
    - image: /assets/img/GenerativeGI/clear-single/img-10059.png
    - image: /assets/img/GenerativeGI/clear-single/img-10059-1.png
    - image: /assets/img/GenerativeGI/clear-single/img-10068.png
    - image: /assets/img/GenerativeGI/clear-single/img-10074.png
    - image: /assets/img/GenerativeGI/clear-single/img-10076.png
    - image: /assets/img/GenerativeGI/clear-single/img-10087.png
    - image: /assets/img/GenerativeGI/clear-single/img-10087-1.png
    - image: /assets/img/GenerativeGI/clear-single/img-10093.png
  - images:  # lexicase no clear
    - image: /assets/img/GenerativeGI/no-clear-lexicase/img-10019.png
    - image: /assets/img/GenerativeGI/no-clear-lexicase/img-10058.png
    - image: /assets/img/GenerativeGI/no-clear-lexicase/img-10062.png
    - image: /assets/img/GenerativeGI/no-clear-lexicase/img-10068.png
    - image: /assets/img/GenerativeGI/no-clear-lexicase/img-10078.png
    - image: /assets/img/GenerativeGI/no-clear-lexicase/img-10084.png
    - image: /assets/img/GenerativeGI/no-clear-lexicase/img-10088.png
    - image: /assets/img/GenerativeGI/no-clear-lexicase/img-10090.png
    - image: /assets/img/GenerativeGI/no-clear-lexicase/img-10092.png
    - image: /assets/img/GenerativeGI/no-clear-lexicase/img-10099.png
  - images:  # lexicase clear
    - image: /assets/img/GenerativeGI/clear-lexicase/img-10056.png
    - image: /assets/img/GenerativeGI/clear-lexicase/img-10073.png
    - image: /assets/img/GenerativeGI/clear-lexicase/img-10085.png
    - image: /assets/img/GenerativeGI/clear-lexicase/img-10088.png
    - image: /assets/img/GenerativeGI/clear-lexicase/img-10092.png
    - image: /assets/img/GenerativeGI/clear-lexicase/img-10095.png
    - image: /assets/img/GenerativeGI/clear-lexicase/img-10096-1.png
    - image: /assets/img/GenerativeGI/clear-lexicase/img-10096.png
    - image: /assets/img/GenerativeGI/clear-lexicase/img-10099-1.png
    - image: /assets/img/GenerativeGI/clear-lexicase/img-10099.png
---

---

- [functioning p5js sketch](tbd)
- [GitHub repository](tbd)

---

**Table of Contents** 

* TOC 
{:toc}

---

<!-- # ECS Tutorial overview -->

We're going to be creating a 2D, top-down, tile-based game demo using p5js.  

## What is ECS?

The Entity-Component-System (ECS) design pattern is a lovely pattern for managing a lot of disparate types of things in your game.  Specifically, you might want to define characters that move, characters that don't move, items, items that hurt you, items that talk to you, NPCs, enemies of varying type, etc.

The nice thing is that those all typically derive from the same base class.  They all need a position and a sprite, for example.  Essentially, we'll define an `Entity` class and inherit from that for all our varying types.

We may also want to give them different abilities/characteristics.  Enter *components* -- the tl;dr is that you will "equip" an entity with a certain component, and that entity will then check its list of components for its abilities.

This is a fairly reductive take on ECS and you can read about it in-depth on [Wikipedia](https://en.wikipedia.org/wiki/Entity_component_system) and [dev.to](https://dev.to/kspeakman/entity-component-system-an-old-new-thing-3224) and [this blog](https://www.richardlord.net/blog/ecs/why-use-an-entity-framework.html).

There also is an ECS framework available as well: [FLECS](https://www.flecs.dev/flecs/) and a correlated [FAQ](https://github.com/SanderMertens/ecs-faq).

## A note on resources

Until you're ready to hire an artist, use royalty/copyright-free resources.  There are a **lot** available online, from [itch.io](https://itch.io/search?q=assets) to [opengameart](https://opengameart.org/) to (my favorite) [kenney.nl](https://kenney.nl).

Whatever you do though:

1. Avoid using copyrighted images (unless if you paid for it)
2. Include the license **every time** you use a resource, and check the attribution requirements for the original file
3. Avoid using AI-generated artwork - hire an artist
4. Since we're using p5js you'll want to become familiar with their documentation.  There are a large number of resources, tutorials, libraries, and **well-written** API documentation pages on their site: [https://p5js.org/reference/](https://p5js.org/reference/).

## Setup

1. Create an account on the p5js editor: [https://editor.p5js.org](p5js online editor) - I've linked my GitHub to it for ease of sign in, however you can use whatever method you prefer.
2. Grab a spritesheet from [kenney.nl](https://kenney.nl): I'll be using the [microrogue resource](https://kenney.nl/assets/micro-roguelike). Make sure you include the License when you upload!
  * Double-note - we're using the "packed" sprite sheet, not individual images!  Both have pros and cons, however uploading hundreds of images to the online editor doesn't work very well.  The non-packed sheet adds a gutter in between images - great for slicing up in something like Tiled or Godot but not as easy to use when calculating based on pixel size (though, to be fair it would just be an offset -- we'll get there).


## First steps

Ok, here we go!  Everything we'll be doing is in the online p5js editor, however you can export it to any website you want after we're done.

### 1. Create a new project (directory structure)

Let's start by defining a directory structure.  By default you'll have some p5 libraries, an `index.html`, and a `sketch.js`. 

If you aren't familiar:

* Any time we add a new `js` file we need to link to it within the `index.html` file - **before** we include the `sketch.js` file.  HTML/JavaScript is (typically) rendered **in-order**, so dependencies must be specified in the correct order.
* p5js uses a few functions to set things up:
  * `setup` runs before the `draw` cycle (or, the forever loop).  Set variable states and do all of your setup in this function.  With p5js 2.0 and beyond, all file loading happens in `setup` as well!
  * `draw` is your forever loop - it runs either as fast as possible or at a specified frame rate.

### 2. Upload your asset files and create empty files

Create a directory on the side called assets and upload your spritesheet **and** its license file.  While you're working there, create files named `components.js` and `entities.js` at the root of your directory (we could add sub-folders for organization, but for this we'll just keep it on the same level).

![uploading](/assets/img/ecs-js/uploading.png)

Note - if you want to upload to a folder then you need to hover over it and click the little dropdown triangle to the side, otherwise you upload to the root of the structure.

![uploading to folder](/assets/img/ecs-js/uploading2.png)

### 3. Wire everything up

In your `index.html` file, add the following lines *above* the call to include `sketch.js`:

```javascript
<script src="components.js"></script>
<script src="entities.js"></script>
<script src="sketch.js"></script>
```

We need to put them above as they need to be parsed before `sketch.js` is parsed (for instance, any global variables we might want to share).

> Note that we are setting up a structure that is good for a quick demo - it would be much better to refactor our code to say, have a `Game` class controlling everything, ingesting the assets, managing entities, etc.  However, we're going to just use a few global variables to get things working.

### 4. Use p5js 2.0.x

Let's start you off with the latest version of p5js - click the version number (next to the gear icon) in the top right and select the latest 2.0.x version - I'm on 2.0.5.  This introduces a plethora of new features - the ones I'm most familiar with are that assets are now loaded in via `async`/`await` calls (instead of using a `preload` function).  Let's try it out:

At the top of your `sketch.js` file (in global space), add a variable:

```javascript
let spritesheet;

...

function setup() {
  ...
```

And then modify your `setup` and `draw` functions to look like this:

```javascript
async function setup() {
  // load in sprite sheet - change the filename to match your file
  await loadImage("assets/spritesheet.png"); 
  createCanvas(400, 400);
}

function draw() {
  background(0);
  image(spritesheet, 0, 0);
}
```

You should now see your spritesheet being drawn to the top left corner!  Note that we also draw the background to give the illusion of animation (once things start to move).  If you didn't redraw the background then things would smear the screen.

![spritesheet](/assets/img/ecs-js/spritesheet-draw.png)

### 5. Draw your character to the screen

In the global space create an object for a character - eventually we'll replace it with a class, however for now it'll just keep an eye on the location:

```javascript
let spritesheet;
let player;

...

async function setup() {
  ...

  player = {x: 20, y: 20};

  ...
}
```

This gives our player a position in 2D space - note that the origin is at the top left corner (and all images/rectanges are drawn with their respective top left corners as the origin).

> You can test this out by the way, when drawing the spritesheet you can use the player position:
>
> `draw(spritesheet, player.x, player.y);`

However, we want to draw a single sprite from our spritesheet, not the entirety of it.

> There are different approaches to loading sprites - we're doing it the 'low-impact' way where we only load in a single image, rather than hundreds.  This has the benefit of saving memory (1 image vs. hundreds) at the cost of a slight bit of complexity.

We need to add a helper function and some information to draw a single sprite.  What we will do is add a variable to tell us the width and height of a sprite (they *should* all be the same size in your spritesheets - some of the more complicated ones use varying sizes and that can be a pain to manually calculate).

Note - if you're using a different spritesheet, check the documentation inside for how large a sprite is.

At the top of `sketch.js` add the following (using your sprite size):

```javascript
const SPRITE_SIZE  = 8; // size of sprite in spritesheet
const SPRITE_SCALE = 4; // amount to scale base sprite
let SPRITE_SCALED  = 1; // calculated scale value
```

What going to do is use the `SPRITE_SIZE` variable to calculate where in the sprite sheet our desired image is located, and then scale it up when drawing so it isn't tiny.

Inside `setup()` make sure you calculate SPRITE_SCALED:

```javascript
async function setup() {
  ...

  SPRITE_SCALED = SPRITE_SCALE * SPRITE_SIZE;

  ...
}
```

Add the following to the bottom of your `sketch.js`:

```javascript
// utility function for drawing a single sprite from the spritesheet 
// note: assumes using the 'packed' version (no spaces/gutters)
function drawSprite(sprite_id, x, y) {
  image(
    spritesheet,   // spritesheet object
    x,             // x location to draw on screen
    y,             // y location to draw on screen
    sprite_scaled, // the **new** width of the sprite
    sprite_scaled, // the **new** height of the sprite
    sprite_dict[sprite_id].c * SPRITE_SIZE, // its x location in the spritesheet
    sprite_dict[sprite_id].r * SPRITE_SIZE, // its y location in the spritesheet
    SPRITE_SIZE,   // the **original** width of the sprite
    SPRITE_SIZE    // the **original** height of the sprite
  );
}
```

This uses the extended syntax of the `image()` function (see [https://p5js.org/reference/p5/image/](https://p5js.org/reference/p5/image/)), however to explain what is going on:

> `image(img, dx, dy, dWidth, dHeight, sx, sy, [sWidth], [sHeight], [fit], [xAlign], [yAlign])`

![image drawing](https://p5js.org/assets/drawImage.png)

HOWEVER, we have an undefined variable!  We need to create a lookup table so that we define which **row** and **column** a specific sprite is!

At the top:

```javascript
let sprite_dict = {
  player:   { r: 0, c: 4 },
  npc:      { r: 0, c: 5 },
  beholder: { r: 0, c: 13 },
  snake:    { r: 1, c: 4 },
};
```

This defines a dictionary for every single character in our game.  Some spritesheets come with a `json` file for easy unpacking, however these ones don't.  Gives you a bit more control!

> Feel free to pick whatever sprites you want for the various characters we'll be drawing.

---

You may have noticed things don't look ... great.  That's because we're scaling a small image up and its edges are supposed to be nice and crisp.

![smoothed](/assets/img/ecs-js/smoothed.png)

Last but not least, we need to direct the canvas to be optimized for pixel art.  If you look at the p5js documentation there are `smooth()` and `noSmooth()` functions, however they don't seem to have the desired effect (note: I don't know why).

After your call to `createCanvas(400, 400)` add the following:

```javascript
async function setup() {
  // load in sprite sheet - change the filename to match your file
  await loadImage("assets/spritesheet.png"); 
  createCanvas(400, 400);

  drawingContext.imageSmoothingEnabled = false;

  ...

}
```

The image should be a bit crisper now.

![nosmooth](/assets/img/ecs-js/nosmoothed.png/)

### 6. Move them around

We have the ability to draw sprites and they should look crisp.  Let's now move our player around the screen.

Before we get into it, you might notice your background doesn't match mine.  That's because I told you to use 0 (black), however the sprite background is somewhat gray (if you're using the microroguelike one).

What you need to do is figure out what the color of your sprite background is and set the color each draw cycle to that!  (If the sprites have a transparent background you don't need to worry about this - and in the olden days we used to filter based on a magic color: <span style='background:#ff00ff'>#ff00ff</span>).

For me, it is <span style='background:#222323;color:#eee;'>#222323</span>, so at the top:

```javascript
const sprite_bg = "#222323";
```

and then in `draw`:

```javascript
function draw() {
  background(sprite_bg);

  ...
}
```

Ok, fun time - p5js handles keypresses in an interesting fashion.  You can use the `keyPressed` function, the `isKeyPressed` function (within `draw`), and so on.  Since we're going for a game where the user can hold down keys, we'll use the `isKeyPressed` approach.

At the bottom of `draw` (i.e., let's handle player input after updating/drawing the game state):

```javascript
function draw() {

  ...

  // enable continuous movement
  if (keyIsDown(LEFT_ARROW) || keyIsDown("a")) {
    player.x--;
  }
  if (keyIsDown(RIGHT_ARROW) || keyIsDown("d")) {
    player.x++;
  }
  if (keyIsDown(UP_ARROW) || keyIsDown("w")) {
    player.y--;
  }
  if (keyIsDown(DOWN_ARROW) || keyIsDown("s")) {
    player.y++;
  }
}
```

Here we're using the arrow or WADS keys for movement.  You can define whichever keys you want to use (or gamepads, for instance).

> Note: again, there are nicer ways of doing this.  Defining a lookup table of keys, for example, so that you can easily have your users configure their controls...

Your player should now move around the screen, a little bit at a time.  You can play with the increment/decrement values to make it faster, however we'll bake that into our Entity later on.

> Note: at this point, you can define any number of sprites on the screen - for example:
> 
> `drawSprite('snake', 100, 100);`

---

[GitHub Repository - Step 1](s1 branch)

---

## Entities

A lot of stuff to get things drawn!  Fortunately, that was a lot of the heavy lifting!  Let's now make our player a bit more useful and turn it into an `Entity` - by doing so we can **easily** abstract out every single other entity in our game.

> Note: the overall goal is to end up with an array of entities that we can loop over and simply call their respective `update()` and `draw()` functions - no spaghetti mess of if statements!  If you've a software engineering background then you might be familiar with the concept of having classes responsible for themselves.  Essentially, we're looking to partition out effort and responsibility.

First, we'll create a **base entity class**.  Move over to `entities.js` and add the following:

```javascript
class Entity {
  constructor(sprite, x, y, w, h) {
    this.sprite = sprite;
    this.position = createVector(x, y);
    this.size = createVector(w, h);
  }

  update() {}

  draw() {
    drawImage(this.sprite, this.position.x, this.position.y);
  }
}
```

This gives us a *base class* that we can extend others off of.  It'll have a sprite variable, a position, and a size.  You'll note we're using `createVector` to store the x/y and w/h of the object.  This is because later on we'll be using some vector math and it is easier to manage now rather than creating temporary variables (plus, it's a bit cleaner).


create a base entity class with empty functions (use vector instead of x,y)
create a moveable entity class
show update/draw
create a player and enemy class
create the array and add the player and enemies
create dvd and follower

## Components

remove custom entities for AI and replace with components

## Handling a map 

generate a map

## Camera follow

.. tbd


## Next steps

This is a taste of what you can do.  A few things:

* p5js is canonically *slow* for JavaScript games as it makes some choices in terms of rendering performance.  It is for teaching and not necessarily production games.  Manually draw to the `canvas` with straight JavaScript or use a framework like [PhaserJS](https://phaser.io) to optimize your game.
  * Check the Performance tab in your browser to profile!  Also, [p5 optimization suggestions](https://github.com/processing/p5.js/wiki/Optimizing-p5.js-Code-for-Performance#identifying-slow-code-profiling)

* Add gameplay!  We've essentially created a 2D walking simulator.

* Wire in Tiled maps!  I've not tried it, but a lot of 2D games use the [Tiled Editor](https://www.mapeditor.org/) for setting up maps, obstacles, etc. [p5.tiledmap](https://github.com/linux-man/p5.tiledmap)

* Check out the other [p5js libraries](https://p5js.org/libraries/)! There are a **ton** of things you can do with it!
  * There is an [ECS library](https://github.com/RandomGamingDev/BasicECSJs/) as well that I've never tried, but it also includes a Scene Manager, which is nice (alternatively, just use a state machine to manage that yourself).

* Make a roguelike game in Godot!  The [SelinaDev tutorial](https://selinadev.github.io/) is a nice introduction to Godot (and more imporantly for this, ECS).


camera + sprites
https://editor.p5js.org/efredericks/sketches/wErqg4bAf

{% include carousel.html height="50" unit="%" duration="15" number="1" %}